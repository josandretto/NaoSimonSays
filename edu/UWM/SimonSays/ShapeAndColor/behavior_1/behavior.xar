<?xml version="1.0" encoding="UTF-8" ?>
<ChoregrapheProject xmlns="http://www.aldebaran-robotics.com/schema/choregraphe/project.xsd" xar_version="3">
    <Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s behavior. Highest level possible." x="0" y="0">
        <bitmap>media/images/box/root.png</bitmap>
        <script language="4">
            <content>
                <![CDATA[]]>
</content>
        </script>
        <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
        <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
        <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
        <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
        <Timeline enable="0">
            <BehaviorLayer name="behavior_layer1">
                <BehaviorKeyframe name="keyframe1" index="1">
                    <Diagram>
                        <Box name="Counter" id="2" localization="-1" tooltip="Represent a counter.&#x0A;&#x0A;Each time the onStart input is stimulated, the counter value is sent on the&#x0A;currentValue output and incremented (or decremented) by Step value, from&#x0A;its Initial value to its Final value set in the parameters. Once the counter value is&#x0A;higher than its Final value, the onReinitialized output is stimulated and&#x0A;the counter is reinitialized to the Initial value.&#x0A;&#x0A;Note: You can also reinitialize the counter by stimulating the onInit&#x0A;input." x="301" y="21">
                            <bitmap>media/images/box/loop.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.initializeParameters()
        if( self.getParameter("Final value") - self.getParameter("Initial value") >= 0 ):
            self.stepSign = +1
        else:
            self.stepSign = -1

    def onUnload(self):
        #~ puts code for box cleanup here
        pass

    def onInput_onNext(self):
        bParamChanged = ( self.nLast != self.getParameter("Final value") or self.nFirst != self.getParameter("Initial value") )
        bEnd = ( self.stepSign * self.nCounter > self.stepSign * self.nLast )
        if( bEnd or bParamChanged ):
            self.onInput_onInit()
        if( not bEnd or bParamChanged ):
            currentCounter = self.nCounter
            self.nCounter = self.nCounter + self.stepSign * self.getParameter("Step value")
            self.currentValue( currentCounter )

    def initializeParameters(self):
        self.nFirst = self.getParameter("Initial value")
        self.nCounter = self.nFirst
        self.nLast = self.getParameter("Final value")

    def onInput_onInit(self):
        self.initializeParameters()
        self.onReinitialized()]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when Diagram is loaded." id="1" />
                            <Input name="onNext" type="1" type_size="1" nature="1" inner="0" tooltip="The counter next value is sent on the currentValue output when a signal is&#x0A;received on this input, unless it reached its Final value, then the onReinitialized&#x0A;output is stimulated." id="2" />
                            <Input name="onInit" type="1" type_size="1" nature="1" inner="0" tooltip="When a signal is received on this input, the counter is reinitialized to its Initial&#x0A;value." id="3" />
                            <Output name="currentValue" type="2" type_size="1" nature="2" inner="0" tooltip="Stimulated for each interaction with the counter current value." id="4" />
                            <Output name="onReinitialized" type="1" type_size="1" nature="2" inner="0" tooltip="Stimulated when the loop is over or if the counter has been reinitialized." id="5" />
                            <Parameter name="Initial value" inherits_from_parent="0" content_type="1" value="0" default_value="0" min="0" max="500" tooltip="The initial value of the counter (for the first iteration)." id="6" />
                            <Parameter name="Step value" inherits_from_parent="0" content_type="1" value="1" default_value="1" min="1" max="500" tooltip="The counter value will be incremented or decremented with this value." id="7" />
                            <Parameter name="Final value" inherits_from_parent="0" content_type="1" value="0" default_value="5" min="0" max="500" tooltip="It is the maximum (if increasing) or the minimum (if decreasing) value of the&#x0A;counter (thus for the last iteration).&#x0A;&#x0A;After this value, if the onStart input is called, the onReinitialized output will be&#x0A;stimulated and the counter will be reinitialized to its Initial value." id="8" />
                        </Box>
                        <Box name="GiveInstruction" id="3" localization="8" tooltip="" x="121" y="399">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[import random

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

    def onLoad(self):
        #put initialization code here
        self.animatedSpeechProxy=ALProxy("ALAnimatedSpeech")
        GREEN_LOW=[60,70,70]
        GREEN_HIGH=[70,255,255]
        PINK_LOW=[163,100,120]
        PINK_HIGH=[167,255,255]
        RED_LOW=[171,143,0]
        RED_HIGH=[179,255,255]
        PURPLE_LOW=[117,51,50]
        PURPLE_HIGH=[128,255,255]
        YELLOW_LOW=[21,0,0]
        YELLOW_HIGH=[29,255,255]
        ORANGE_LOW=[0,152,162]
        ORANGE_HIGH=[0,179,255]
        NEON_YELLOW_LOW=[9,96,103]
        NEON_YELLOW_HIGH=[41,212,255]
        shapes=('circle','square','rectangle','triangle','pentagon')

        global objectDict
        #put all the color ranges into a single list
        #objectDict={'green':[GREEN_LOW,GREEN_HIGH],
               #     'pink':[PINK_LOW,PINK_HIGH],
                #    'purple':[PURPLE_LOW,PURPLE_HIGH],
                #    'yellow':[YELLOW_LOW,YELLOW_HIGH],
                #    'orange':[ORANGE_LOW,ORANGE_HIGH],
                #    'red':[RED_LOW,RED_HIGH],
                 #   'neon yellow':[NEON_YELLOW_LOW,NEON_YELLOW_HIGH]}
        objectDict={'yellow':[YELLOW_LOW,YELLOW_HIGH]}

        shapeDict={}
        for s in shapes:
            for k in objectDict.keys():
                tmp=objectDict[k]
                tmp.append(k)
                tmp.append(s)
                shapeDict[k+' '+s]=tmp
        objectDict=shapeDict

        self.instructionList=[]
        #for k in objectDict.keys():
       #     self.instructionList.append((objectDict[k][2],objectDict[k][3],"Show me the "+k+"."))
        self.instructionList.append(('yellow','square',"Show me the yellow square."))

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        #i=random.randint(0,len(self.instructionList)-2)
        i=0
        simon=['',"Simon says "]
        simonSays=random.choice(simon)
        simonSays="Simon says"
        toSay=simonSays+self.instructionList[i][2]
        self.animatedSpeechProxy.say(toSay)
        toSend=(self.instructionList[i][0],self.instructionList[i][1],True if simonSays=='Simon says' else False)
        self.onStopped(toSend) #activate the output of the box


    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="2" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="0" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
                        </Box>
                        <Box name="Wait" id="6" localization="8" tooltip="Wait a moment before sending a signal on the output. &#x0A;Can be stopped anytime. &#x0A;Stimulating the input again before output is activated restarts the waiting period.&#x0A;" x="418" y="419">
                            <bitmap>media/images/box/wait.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self, False)

    def onLoad(self):
        self.waiting = None

    def onUnload(self):
        self.cancelWaiting()

    def triggerOutput(self):
        self.timerOutput(self._color)

    def cancelWaiting(self):
        if self.waiting:
            self.waiting.cancel()
        self.waiting = None

    def onInput_onStart(self,color):
        self._color=color
        self.cancelWaiting()
        import qi
        self.waiting = qi.async(self.triggerOutput, delay=int(self.getParameter("Timeout (s)") * 1000 * 1000))

    def onInput_onStop(self):
        if self.getParameter("Trigger timerOutput if cancelled") and self.waiting and self.waiting.isRunning():
            self.timerOutput()
        self.onUnload()]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Start the Wait box with the configured timeout value." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the wait and stimulate the output." id="3" />
                            <Output name="timerOutput" type="0" type_size="1" nature="1" inner="0" tooltip="Send a bang once time set in parameters is elapsed, or if the box is stopped and the appropriate parameter is set." id="4" />
                            <Parameter name="Timeout (s)" inherits_from_parent="0" content_type="2" value="5" default_value="1" min="0" max="5000" tooltip="Duration the box waits before stimulating the output." id="5" />
                            <Parameter name="Trigger timerOutput if cancelled" inherits_from_parent="0" content_type="0" value="0" default_value="1" tooltip="If the box is currently waiting and cancelled, output will be stimulated." id="6" />
                        </Box>
                        <Box name="CheckSimonSays" id="4" localization="8" tooltip="" x="731" y="421">
                            <bitmap>media/images/box/box-python-script.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[import vision_definitions
import cv2
import numpy as np

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

    def onLoad(self):
        #put initialization code here
        self._video=ALProxy('ALVideoDevice')
        camera=0
        resolution=vision_definitions.kVGA
        colorSpace=vision_definitions.kRGBColorSpace
        fps=10
        #subscribe to the camera
        self._cameraClient=self._video.subscribeCamera("detector", camera, resolution,colorSpace,fps)

        #set width and height of images
        self._imageWidth=640
        self._imageHeight=480

    def onUnload(self):
        #put clean-up code here
        self._video.unsubscribe(self._cameraClient)

    def onInput_onStart(self,color):
        global objectDict
        self.animatedSpeechProxy = ALProxy("ALTextToSpeech")
        #self.animatedSpeechProxy.say(color[0])

        image=None

        #get a picture from Nao
        result = self._video.getImageRemote(self._cameraClient)
        self._video.releaseImage(self._cameraClient)

        #make sure a picture is received before processing the image
        if result is None:
            pass
        elif result[6] is None:
            pass
        else:
            try:
                # the image is a bitstring, so reshape it into a multi-dimensional array with the RGB values of pixel with (x,y)
                # location at image[x][y]
                image=np.fromstring(result[6],np.uint8).reshape(480,640,3)

                # release image buffer locked by getImageLocal(). Not mandatory for GetImageRemote(), but recommended


                # Convert the image's RGB values to HSV (Hue, Saturation, Value)...at first I used RGB, but read that HSV can work well for filtering
                im=cv2.cvtColor(image,cv2.COLOR_RGB2HSV)
                im=cv2.resize(im,None,fx=.75,fy=.75,interpolation=cv2.INTER_CUBIC)
                lower=objectDict[color[0]+' '+color[1]][0]
                upper=objectDict[color[0]+' '+color[1]][1]

                #convert the HSV values to the correct format
                lower=np.array(lower,dtype="uint8")
                upper=np.array(upper,dtype="uint8")

                #create a mask of the image where pixels that value in the range [lower,upper] are white and everything else is black
                mask=cv2.inRange(im,lower,upper)

                #use dilation and erosion to remove some of the noise in the mask
                kernel = np.ones((5,5),np.uint8)
                mask=cv2.dilate(mask,kernel,iterations=1)
                mask=cv2.erode(mask,kernel,iterations=1)

                #find boundaries between the black and white areas of the mask
                contours,hierarchy=cv2.findContours(mask,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
                #get the area of all the regions returned by cv2.findContours
                areas=[cv2.contourArea(c) for c in contours]
                #get the index of the region with the largest area
                if (len(areas)==0):
                    self.animatedSpeechProxy.say("no contours")
                elif(len(areas)>0):
                    max_index=np.argmax(areas)
                    #get the contour with the largest area
                    cnt=contours[max_index]

                    perimeter=cv2.arcLength(cnt,True)
                    approximateShape = cv2.approxPolyDP(c,0.07*perimeter,True)
                    shape="no idea"
                    if len(approximateShape)==3:
                        shape="triangle"

                    elif len(approximateShape)==4:
                        (x,y,w,h) = cv2.boundingRect(approximateShape)
                        ar = w/float(h)
                        shape = "square" if ar >=.95 or ar<=1.05 else "rectangle"

                    elif len(approximateShape)==5:
                        shape = "pentagon"
                    else:
                        shape="circle"

                    self.animatedSpeechProxy.say(shape)

                    if (cv2.contourArea(cnt)>150) and color[2]:
                         if color[1]==shape:
                            self.animatedSpeechProxy.say('That is correct! That is the '+color[0]+'         '+color[1]+".")
                         else:
                            self.animatedSpeechProxy.say('Close! That is the '+color[0]+' '+color[1]+" . I wanted to see the "+color[0]+' '+color[1])
                    elif (cv2.contourArea(cnt)>150):
                        self.animatedSpeechProxy.say('That is the '+color[0]+' '+color[1]+", but Simon did not say to show me the " + color[0]+' '+color[1]+".")
                    elif color[2]:
                        self.animatedSpeechProxy.say("Simon asked to see the "+color[0]+' '+objectDict[color[0]][2]+ " but Simon does't see it. Let's try again.")
                    else:
                        self.animatedSpeechProxy.say("Great job, I did not say Simon says.")
            except RuntimeError:
                self.animatedSpeechProxy.say('There was a problem')
        self.onStopped() #activate the output of the box


    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="0" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
                        </Box>
                        <Link inputowner="0" indexofinput="4" outputowner="2" indexofoutput="5" />
                        <Link inputowner="3" indexofinput="2" outputowner="2" indexofoutput="4" />
                        <Link inputowner="6" indexofinput="2" outputowner="3" indexofoutput="4" />
                        <Link inputowner="4" indexofinput="2" outputowner="6" indexofoutput="4" />
                        <Link inputowner="2" indexofinput="2" outputowner="4" indexofoutput="4" />
                        <Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="2" />
                    </Diagram>
                </BehaviorKeyframe>
            </BehaviorLayer>
        </Timeline>
    </Box>
</ChoregrapheProject>
